import { MinDB } from './index';
import { TYPES } from './base';
export declare class Multi {
    private min;
    private queue;
    constructor(min: MinDB);
    exec(): Promise<any[]>;
    exists(key: string): this;
    is(key: string, type: TYPES): this;
    renamenx(key: string, newKey: string): this;
    rename(key: string, newKey: string): this;
    set(key: string, value: any): this;
    setnx(key: string, value: any): this;
    setex(key: string, seconds: number, value: any): this;
    psetex(key: string, milliseconds: number, value: any): this;
    mset(doc: {
        [key: string]: any;
    }): this;
    append(key: string, value: string): this;
    get(key: string): this;
    getrange(key: string, start: number, end: number): this;
    mget(keys: string[]): this;
    getset(key: string, value: any): this;
    strlen(key: string): this;
    incr(key: string): this;
    del(key: string): this;
    keys(pattern?: string): this;
    randomKey(): this;
    type(key: string): this;
    empty(): this;
    hset(key: string, field: string, value: any): this;
    hsetnx(key: string, field: string, value: any): this;
    hexists(key: string, field: string): this;
    hmset(key: string, doc: {
        [field: string]: any;
    }): this;
    hget(key: string, field: string): this;
    hmget(key: string, fields: string[]): this;
    hgetall(key: string): this;
    hdel(key: string, field: string): this;
    hlen(key: string): this;
    hkeys(key: string): this;
    hincr(key: string, field: string): this;
    hincrby(key: string, field: string, increment: number): this;
    hincrbyfloat(key: string, field: string, increment: number): this;
    hdecr(key: string, field: string): this;
    hdecrby(key: string, field: string, decrement: number): this;
    hdecrbyfloat(key: string, field: string, decrement: number): this;
    lpush(key: string, ...values: any[]): this;
    lpushx(key: string, ...values: any[]): this;
    rpush(key: string, ...values: any[]): this;
    rpushx(key: string, ...values: any[]): this;
    lpop(key: string): this;
    rpop(key: string): this;
    llen(key: string): this;
    lrange(key: string, start: number, stop: number): this;
    lrem(key: string, count: number, value: any): this;
    lset(key: string, index: number, value: any): this;
    ltrim(key: string, start: number, stop: number): this;
    lindex(key: string, index: number): this;
    linsertBefore(key: string, pivot: any, value: any): this;
    linsertAfter(key: string, pivot: any, value: any): this;
    rpoplpush(src: string, dest: string): this;
    lpoprpush(src: string, dest: string): this;
    sadd(key: string, ...members: any[]): this;
    srem(key: string, ...members: any[]): this;
    smembers(key: string): this;
    sismember(key: string, value: any): this;
    scard(key: string): this;
    smove(src: string, dest: string, member: any): this;
    srandmember(key: string): this;
    spop(key: string): this;
    sunion(...keys: string[]): this;
    sunionstore(dest: string, ...keys: string[]): this;
    sinter(...keys: string[]): this;
    sinterstore(dest: string, ...keys: string[]): this;
    sdiff(...keys: string[]): this;
    sdiffstore(dest: string, ...keys: string[]): this;
    zadd(key: string, score: number, member: any): this;
    zcard(key: string): this;
    zcount(key: string, min: number, max: number): this;
    zrem(key: string, ...members: any[]): this;
    zscore(key: string, member: any): this;
    zrange(key: string, min: number, max: number): this;
    zrevrange(key: string, min: number, max: number): this;
    zincrby(key: string, increment: number, member: any): this;
    zdecrby(key: string, decrement: number, member: any): this;
    zrank(key: string, member: any): this;
    zrevrank(key: string, member: any): this;
}
